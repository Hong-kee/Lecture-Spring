# 1. Call by value & Call by reference

## 1.1 Call by value(CBV)
>CBV는 Primitive type과 같은 대상을 할당받아 사용된다.

        int num = 10;
        int[] arr = {1, 2};
        change(num);//CBV
        
        public static void change(int num) {
        /**
         * main()에 있는 num 값과 전혀 다른 변수다.
         */
        num += 100;
    }
>다음과 같은 코드가 있다고 하자. change 메서드에 기존 로컬 변수 num = 10을 parameter로 넘겨 주었다. change 메서드를 보면 num += 100이라는 계산을 하고 끝내는데 과연 끝나고 main 메서드의 num 값은 변할까? 정답은 아니다.
>parameter로 넘겨준 num의 값과 main 메서드의 num의 값은 이름은 같지만 전혀 다른 변수이다. 

## 1.2 Call by reference
>&, |, ^, !가 있고 결과는 boolean형으로 나온다. (true, false)

## 1.3 복합 대입 연산자
>변수를 중복하여 사용하는 것을 막아준다.
>+=, -=, *=, /=, %=이 있다. num += 1과 num = num + 1은 동일한 연산 결과를 보여준다.

## 1.4 증감자, 감소자
### 1.4.1 전치 증감자
int x = 10;

int y = 0;

y = ++x;

System.out.println("x : " + ++x); //12

>다음과 같은 코드가 있다고 하자. 그렇다면 y에는 x에 1이 증가된 값인 11이 들어가고 x는 1증가된 11이 된다. 그 후 x 출력 부분을 보면 전치 증감자로 인해 1이 증가된 12가 출력된다. 

### 1.4.2 후치 증감자
int x = 10;

int y = 0;

y = ++x;

System.out.println("y : " + y++); //11

>다음과 같은 코드가 있다고 하자. 그렇다면 y에는 x에 1이 증가된 값인 11이 들어가고 x는 1증가된 11이 된다. 그 후 y 출력 부분을 보면 후치 증감자가 있기에 출력 결과엔 영향을 주지 않고 11을 출력한다. 다만 y는 12로 증가된 상태로 끝난다.

## 1.5 삼항 연산자(조건 연산자)
>기본 포맷은 다음과 같다.

자료형 변수명 = 조건문? 참일 때 : 거짓일 때;

>예시를 들어보자.

int a = 20, b = 30, max;

max = a < b ? a : b;

System.out.println(max); //30
