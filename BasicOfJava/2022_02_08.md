# 객체지향(OOP)

## 1.1 객체지향의 탄생

 &nbsp;SW가 대용량화 됨에 따라 개발 기간과 비용이 증가했다. 따라서 경영진들은 빠르게 개발할 수 있는 방법은 뭐가 있을까?에 대한 모색을 했고 변화에 민첩하게 대응하길 바랐다.  
 &nbsp;HW의 발전 속도는 빨라지고 SW의 발전 속도는 더디게 되면서 HW의 기본적인 사양을 잡아 먹더라도 SW의 개발 속도를 빠르게 하기 위해 모듈화, 캡슐화 개념을 접목시킨 
 객체지향 개념이 탄생했다.  
 
   
 ## 1.2 객체지향의 장점
 ### SW의 생산성 향상  
 &nbsp;객체지향 프로그래밍은 다형성, 캡슐화 등 SW의 재사용을 지향한다. 클래스를 상속받고 객체를 재사용하거나, 부분적인 수정을 통해 SW를 작성하는 부담을 줄여준다.  
   
 ### 실세계에 대한 쉬운 모델링
 &nbsp;SW 특성상 실세계와 물체들이 상호 작용하듯 SW 또한 비슷하다. 따라서 실세계에 대한 모델링을 더 쉽게 직관적으로 할 수 있다.  
 
 ### 보안성
 &nbsp;객체지향의 특성 중 캡슐화를 통해 데이터 은닉이 가능하여 보안성이 뛰어나다. Java Bean Property Rules에 따라 getter / setter로 값을 가져오거나 초기화를 할 수 있다.  
   
   
 ## 1.3 객체지향의 단점  
 ### 느린 실행 속도  
 &nbsp;객체지향은 절차지향과 비교해서 속도가 느리다. 그 이유는 캡슐화와 격리구조, 객체지향의 특성상 ***모든 것을 객체로 생각하기에 추가적인 포인터의 크기와 메모리 연산에 대한 비용***이 들어가기 때문이다.  
   
---
     
 # 객체  
 &nbsp;상태(데이터)와 행동(기능)으로 규정할 수 있는 것이다. 즉, 데이터는 멤버변수(필드)를 말하고 기능은 메서드를 말한다.  
   
   
 ## 2.1 객체 구현 방법  
 &nbsp;공통된 객체의 성격(필드와 메서드)에 맞는 클래스를 통해서 만든다. 즉, 기능들을 가능한 구분지어서 잘 갈라놓아야 한다.  
 예를 들자면, 계좌와 관련해서 객체를 만들고 싶다고 하자. 그렇다면 상태(필드)는 계좌번호, 계좌주, 잔액 등이 있을 것이고 기능(메서드)는 입금하기, 출금하기가 있을 것이다.  
 &nbsp;이렇게 상태(필드)와 기능(메서드)를 정의하는 것을 ***객체 모델링(객체 추상화)*** 라고 한다.  
   
   순서는 다음과 같이 정의할 수 있다.  
   1. 객체에 대한 요구분석  
   2. 객체에 대한 공통된 상태와 기능을 추출  
   3. 상태와 기능에 대한 클래스(필드, 메서드)를 구현  
  
  ## 2.2 생성자(Constructor)  
  ### 생성자 구현 방법  
  - 리턴형이 없다.(void 마저 없다.)  
  - 이름은 클래스명이다.  
  - 초기화 하고자 하는 데이터를 파라미터로 입력 받는다.  
  ### 생성자 호출
  - 생성자는 직접 호출하지 않고 객체가 생성 될 때 자동으로 호출된다.  
  ```java
Member member = new Member(); // 객체 생성되면서 기본 생성자 호출
//생성자가 없을 때
Member member = new Member();
member.name = "홍길동";
member.age = 20;
member.address = "서울특별시 ~";

//생성자가 있을 때
Member Member = new Member("홍길동", 20, "서울특별시~");
  ```  
  - 생성자를 호출시 파라미터의 갯수와 데이터형을 통해 구분한다.  
  - 객체를 생성할 때 반드시 해당 생성자를 확인해야 한다.
  
